<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>RobotPlatformè¯­éŸ³å¯¹è¯</title>
    <style>
        body {
            font-family: 'Arial', sans-serif;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f5f5f5;
        }

        h1 {
            color: #333;
            text-align: center;
        }

        .chat-container {
            background-color: white;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            padding: 20px;
            margin-bottom: 20px;
            max-height: 500px;
            overflow-y: auto;
        }

        .message {
            margin-bottom: 15px;
            padding: 10px;
            border-radius: 5px;
            position: relative;
        }

        .user-message {
            background-color: #e3f2fd;
            text-align: right;
            margin-left: 60px;
        }

        .robot-message {
            background-color: #f1f1f1;
            margin-right: 60px;
        }

        .transcription-message {
            background-color: #e8f5e9;
            font-style: italic;
            margin-left: 60px;
            text-align: right;
            font-size: 0.9em;
        }

        .error-message {
            background-color: #ffebee;
            color: #c62828;
            font-weight: bold;
        }

        .system-message {
            background-color: #fff8e1;
            color: #ff8f00;
            text-align: center;
            font-style: italic;
            padding: 5px 10px;
            margin: 10px 0;
        }

        .message-time {
            font-size: 0.7em;
            color: #757575;
            margin-top: 5px;
        }

        .control-container {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .button-group {
            display: flex;
            gap: 10px;
        }

        button {
            padding: 10px 15px;
            border: none;
            border-radius: 5px;
            color: white;
            cursor: pointer;
            font-size: 16px;
            flex: 1;
        }

        .primary-btn {
            background-color: #1976d2;
        }

        .primary-btn:hover {
            background-color: #1565c0;
        }

        .danger-btn {
            background-color: #e53935;
        }

        .danger-btn:hover {
            background-color: #c62828;
        }

        button:disabled {
            background-color: #bbdefb;
            cursor: not-allowed;
        }

        .status {
            text-align: center;
            margin-top: 10px;
            font-style: italic;
            color: #666;
        }

        .loading {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid rgba(0, 0, 0, 0.1);
            border-radius: 50%;
            border-top-color: #1976d2;
            animation: spin 1s ease-in-out infinite;
            margin-left: 5px;
        }

        .message-avatar {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            position: absolute;
            top: 10px;
        }

        .user-avatar {
            right: -50px;
            background-color: #bbdefb;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #1976d2;
            font-weight: bold;
        }

        .robot-avatar {
            left: -50px;
            background-color: #c8e6c9;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #388e3c;
            font-weight: bold;
        }

        .text-input-container {
            display: flex;
            gap: 10px;
            margin-top: 10px;
        }

        #textInput {
            flex: 1;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 5px;
            font-size: 16px;
        }

        #sendTextBtn {
            background-color: #388e3c;
        }

        #sendTextBtn:hover {
            background-color: #2e7d32;
        }

        .playing-indicator {
            display: inline-block;
            margin-left: 10px;
            color: #1976d2;
            animation: pulse 1s infinite;
        }

        @keyframes spin {
            to {
                transform: rotate(360deg);
            }
        }

        @keyframes pulse {
            0% {
                opacity: 0.3;
            }

            50% {
                opacity: 1;
            }

            100% {
                opacity: 0.3;
            }
        }

        .session-info {
            text-align: center;
            font-size: 0.8em;
            color: #757575;
            margin-bottom: 10px;
        }
    </style>
</head>

<body>
    <h1>RobotPlatformè¯­éŸ³å¯¹è¯</h1>

    <div class="session-info" id="sessionInfo"></div>

    <div class="chat-container" id="chatContainer">
        <div class="message robot-message">
            æ‚¨å¥½ï¼Œæˆ‘æ˜¯RobotPlatformï¼Œè¯·ç‚¹å‡»ä¸‹æ–¹æŒ‰é’®å¼€å§‹è¯­éŸ³å¯¹è¯ã€‚
            <div class="message-avatar robot-avatar">AI</div>
        </div>
    </div>

    <div class="control-container">
        <div class="button-group">
            <button id="startBtn" class="primary-btn">å¼€å§‹å½•éŸ³</button>
            <button id="stopBtn" class="danger-btn" disabled>åœæ­¢å½•éŸ³</button>
            <button id="resetBtn" class="danger-btn">é‡ç½®ä¼šè¯</button>
        </div>
        <div class="text-input-container">
            <input type="text" id="textInput" placeholder="æˆ–è€…è¾“å…¥æ–‡å­—è¿›è¡Œå¯¹è¯...">
            <button id="sendTextBtn" class="primary-btn">å‘é€</button>
        </div>
        <div class="status" id="status">æœªè¿æ¥</div>
    </div>

    <script>
        // å…¨å±€å˜é‡
        let websocket = null;
        let mediaRecorder = null;
        let audioChunks = [];
        let sessionId = "voice"; // ä½¿ç”¨å›ºå®šä¼šè¯ID
        let currentAudio = null;
        let isConnecting = false; // é˜²æ­¢é‡å¤è¿æ¥
        let heartbeatInterval = null; // å¿ƒè·³è®¡æ—¶å™¨
        let reconnectTimeout = null; // é‡è¿è®¡æ—¶å™¨
        let isAIPlaying = false; // æ·»åŠ AIæ’­æ”¾çŠ¶æ€æ ‡å¿—
        let currentAudioSource = null; // æ·»åŠ å½“å‰éŸ³é¢‘æºå¼•ç”¨
        const HEARTBEAT_INTERVAL = 20000; // å‘é€å¿ƒè·³åŒ…çš„é—´éš”(æ¯«ç§’)
        const RECONNECT_INTERVAL = 3000;  // é‡è¿é—´éš”(æ¯«ç§’)

        // éŸ³é¢‘é…ç½®
        const AUDIO_CONFIG = {
            duration: 600000,  // æœ€é•¿å½•éŸ³æ—¶é•¿ï¼Œå•ä½ï¼šms
            sampleRate: 16000,  // ç›®æ ‡é‡‡æ ·ç‡
            numberOfChannels: 1,  // å½•éŸ³é€šé“æ•°
            encodeBitRate: 48000,  // ç¼–ç ç ç‡
            format: 'PCM',  // éŸ³é¢‘æ ¼å¼
            frameSize: 1,  // å¸§å¤§å°
            needFrame: true  // å¯ç”¨å¸§å½•åˆ¶
        };

        // ç¼“å†²åŒºå¤§å°
        const CHUNK_SIZE = 960;  // æ¯æ¬¡å‘é€çš„æ•°æ®å—å¤§å°ï¼Œå‡å°ä»¥æé«˜å“åº”é€Ÿåº¦
        const MAX_BUFFER_TIME = 100; // æœ€å¤§ç¼“å†²æ—¶é—´ï¼ˆæ¯«ç§’ï¼‰ï¼Œä»200mså‡å°‘åˆ°100msï¼ŒåŠ å¿«å‘é€é¢‘ç‡

        // å…¨å±€éŸ³é¢‘æµå¼æ’­æ”¾å˜é‡
        let audioContext = null;
        let audioQueue = [];
        let isPlaying = false;

        // DOMå…ƒç´ 
        const chatContainer = document.getElementById('chatContainer');
        const startBtn = document.getElementById('startBtn');
        const stopBtn = document.getElementById('stopBtn');
        const resetBtn = document.getElementById('resetBtn');
        const statusEl = document.getElementById('status');
        const textInput = document.getElementById('textInput');
        const sendTextBtn = document.getElementById('sendTextBtn');
        const sessionInfoEl = document.getElementById('sessionInfo');

        // æ›´æ–°ä¼šè¯ä¿¡æ¯
        function updateSessionInfo() {
            sessionInfoEl.textContent = `ä¼šè¯ID: ${sessionId}`;
        }

        // å¯åŠ¨å¿ƒè·³
        function startHeartbeat() {
            stopHeartbeat(); // å…ˆåœæ­¢å·²æœ‰çš„å¿ƒè·³

            heartbeatInterval = setInterval(() => {
                if (websocket && websocket.readyState === WebSocket.OPEN) {
                    // å‘é€å¿ƒè·³åŒ…
                    console.log('å‘é€å¿ƒè·³åŒ…...');
                    try {
                        // ä½¿ç”¨pingç±»å‹æ¶ˆæ¯ä½œä¸ºå¿ƒè·³åŒ…
                        sendMessage({
                            type: 'ping',
                            sessionId: sessionId,
                            timestamp: Date.now()
                        });
                    } catch (e) {
                        console.error('å‘é€å¿ƒè·³åŒ…å¤±è´¥:', e);
                    }
                } else {
                    console.warn('WebSocketæœªè¿æ¥ï¼Œæ— æ³•å‘é€å¿ƒè·³åŒ…');
                    reconnectIfNeeded();
                }
            }, HEARTBEAT_INTERVAL);

            console.log('å¿ƒè·³æœºåˆ¶å·²å¯åŠ¨ï¼Œé—´éš”:', HEARTBEAT_INTERVAL, 'ms');
        }

        // åœæ­¢å¿ƒè·³
        function stopHeartbeat() {
            if (heartbeatInterval) {
                clearInterval(heartbeatInterval);
                heartbeatInterval = null;
                console.log('å¿ƒè·³æœºåˆ¶å·²åœæ­¢');
            }
        }

        // æ£€æŸ¥æ˜¯å¦éœ€è¦é‡è¿
        function reconnectIfNeeded() {
            if (!websocket || websocket.readyState === WebSocket.CLOSED || websocket.readyState === WebSocket.CLOSING) {
                console.log('æ£€æµ‹åˆ°WebSocketå·²æ–­å¼€ï¼Œå‡†å¤‡é‡è¿...');

                // é¿å…å¤šæ¬¡é‡è¿
                if (!reconnectTimeout && !isConnecting) {
                    reconnectTimeout = setTimeout(() => {
                        reconnectTimeout = null;
                        connectWebSocket();
                    }, RECONNECT_INTERVAL);

                    console.log('å·²å®‰æ’é‡è¿ä»»åŠ¡ï¼Œå°†åœ¨', RECONNECT_INTERVAL, 'msåæ‰§è¡Œ');
                }
            }
        }

        // åˆå§‹åŒ–WebSocketè¿æ¥
        function connectWebSocket() {
            if (isConnecting || (websocket && websocket.readyState === WebSocket.CONNECTING)) {
                console.log('WebSocketè¿æ¥å·²åœ¨è¿›è¡Œä¸­ï¼Œé¿å…é‡å¤è¿æ¥');
                return;
            }

            if (websocket && websocket.readyState === WebSocket.OPEN) {
                console.log('WebSocketå·²è¿æ¥ï¼Œæ— éœ€é‡æ–°è¿æ¥');
                return;
            }

            // æ¸…ç†ç°æœ‰è¿æ¥
            if (websocket) {
                try {
                    websocket.onclose = null; // ç§»é™¤ç°æœ‰çš„å…³é—­å¤„ç†å™¨ä»¥é¿å…è§¦å‘é‡è¿
                    websocket.onerror = null;
                    websocket.onmessage = null;
                    websocket.onopen = null;
                    websocket.close();
                } catch (e) {
                    console.error('å…³é—­ç°æœ‰WebSocketè¿æ¥å¤±è´¥:', e);
                }
                websocket = null;
            }

            isConnecting = true;
            statusEl.textContent = "æ­£åœ¨è¿æ¥...";

            const wsUrl = `ws://${window.location.host}/robotplatform/ws/voice/${sessionId}`;
            console.log('æ­£åœ¨è¿æ¥WebSocket:', wsUrl);

            try {
                websocket = new WebSocket(wsUrl);

                websocket.onopen = function () {
                    console.log('WebSocketè¿æ¥å·²æ‰“å¼€');
                    statusEl.textContent = "å·²è¿æ¥";
                    startBtn.disabled = false;
                    sendTextBtn.disabled = false;
                    updateSessionInfo();
                    isConnecting = false;

                    // è¿æ¥æˆåŠŸåå¯åŠ¨å¿ƒè·³
                    startHeartbeat();

                    // è¿æ¥æˆåŠŸæ—¶å‘é€ç™»å½•æ¶ˆæ¯
                    sendMessage({
                        type: 'connect',
                        sessionId: sessionId,
                        timestamp: Date.now()
                    });
                };

                websocket.onmessage = function (event) {
                    //  console.log('æ”¶åˆ°WebSocketæ¶ˆæ¯:', event.data);
                    try {
                        const message = JSON.parse(event.data);

                        // å¤„ç†æœåŠ¡å™¨çš„pongå“åº”
                        if (message.type === 'pong') {
                            console.log('æ”¶åˆ°å¿ƒè·³å“åº”');
                            return;
                        }

                        handleWebSocketMessage(message);
                    } catch (e) {
                        console.error('è§£ææ¶ˆæ¯å¤±è´¥:', e);
                        addMessage("æ¶ˆæ¯è§£æå¤±è´¥: " + e.message, "error");
                    }
                };

                websocket.onclose = function (event) {
                    console.log('WebSocketè¿æ¥å…³é—­, ä»£ç :', event.code, 'åŸå› :', event.reason);
                    statusEl.textContent = "è¿æ¥å·²å…³é—­";
                    startBtn.disabled = false;
                    stopBtn.disabled = true;
                    isConnecting = false;

                    // åœæ­¢å¿ƒè·³
                    stopHeartbeat();

                    // è¿æ¥å…³é—­æ—¶ï¼Œå¦‚æœä¸æ˜¯ä¸»åŠ¨å…³é—­ï¼Œåˆ™å°è¯•é‡è¿
                    if (event.code !== 1000 && document.visibilityState === 'visible') {
                        addMessage("è¿æ¥å·²æ–­å¼€ï¼Œæ­£åœ¨å°è¯•é‡æ–°è¿æ¥...", "system");
                        reconnectIfNeeded();
                    }
                };

                websocket.onerror = function (error) {
                    console.error('WebSocketé”™è¯¯:', error);
                    statusEl.textContent = "è¿æ¥é”™è¯¯";
                    addMessage("è¿æ¥é”™è¯¯ï¼Œæ­£åœ¨å°è¯•é‡æ–°è¿æ¥", "error");
                    isConnecting = false;

                    // è¿æ¥é”™è¯¯æ—¶å°è¯•é‡è¿
                    reconnectIfNeeded();
                };
            } catch (e) {
                console.error('åˆ›å»ºWebSocketè¿æ¥å¤±è´¥:', e);
                statusEl.textContent = "è¿æ¥å¤±è´¥";
                isConnecting = false;

                // è¿æ¥å‡ºé”™æ—¶å°è¯•é‡è¿
                reconnectIfNeeded();
            }
        }

        // å¤„ç†WebSocketæ¶ˆæ¯
        function handleWebSocketMessage(message) {
            const startTime = performance.now();
            console.log('[WebSocketæ¶ˆæ¯] æ”¶åˆ°æ¶ˆæ¯ç±»å‹:', message.type);

            if (message.type === 'text') {
                console.log('[WebSocketæ¶ˆæ¯] æ”¶åˆ°æ–‡æœ¬æ¶ˆæ¯, é•¿åº¦:', message.text ? message.text.length : 0);
                const renderStart = performance.now();
                addMessage(message.text, 'robot');
                console.log('[WebSocketæ¶ˆæ¯] æ¸²æŸ“æ–‡æœ¬æ¶ˆæ¯è€—æ—¶:', (performance.now() - renderStart).toFixed(2) + 'ms');
            } else if (message.type === 'audio') {
                console.log('[WebSocketæ¶ˆæ¯] æ”¶åˆ°éŸ³é¢‘æ•°æ®, é•¿åº¦:', message.audioData ? message.audioData.length : 0);
                const processStart = performance.now();
                playPcmChunk(message.audioData);
                console.log('[WebSocketæ¶ˆæ¯] å¤„ç†éŸ³é¢‘æ•°æ®è€—æ—¶:', (performance.now() - processStart).toFixed(2) + 'ms');
            } else if (message.type === 'transcription') {
                console.log('[WebSocketæ¶ˆæ¯] æ”¶åˆ°è½¬å½•æ¶ˆæ¯, æ–‡æœ¬:', message.text);
                const renderStart = performance.now();
                addMessage(message.text, 'transcription');
                console.log('[WebSocketæ¶ˆæ¯] æ¸²æŸ“è½¬å½•æ¶ˆæ¯è€—æ—¶:', (performance.now() - renderStart).toFixed(2) + 'ms');
            } else if (message.type === 'error') {
                console.log('[WebSocketæ¶ˆæ¯] æ”¶åˆ°é”™è¯¯æ¶ˆæ¯:', message.errorMessage);
                addMessage(message.errorMessage || "æœªçŸ¥é”™è¯¯", 'error');
            } else {
                console.warn('[WebSocketæ¶ˆæ¯] æœªçŸ¥æ¶ˆæ¯ç±»å‹:', message.type);
                console.warn('[WebSocketæ¶ˆæ¯] æœªçŸ¥æ¶ˆæ¯å†…å®¹:', JSON.stringify(message));
            }

            // å¤„ç†å®Œæˆåæ›´æ–°çŠ¶æ€
            statusEl.textContent = "å·²è¿æ¥";
            console.log('[WebSocketæ¶ˆæ¯] æ€»å¤„ç†è€—æ—¶:', (performance.now() - startTime).toFixed(2) + 'ms');
        }

        function initAudioContext() {
            if (!audioContext) {
                audioContext = new (window.AudioContext || window.webkitAudioContext)({ sampleRate: 24000 });
            }
        }

        function playPcmChunk(base64Audio) {
            if (!base64Audio) return;
            
            // è®°å½•å¼€å§‹æ—¶é—´
            const startTime = performance.now();
            console.log("[éŸ³é¢‘å¤„ç†] å¼€å§‹å¤„ç†éŸ³é¢‘æ•°æ®");
            
            initAudioContext();
            console.log("[éŸ³é¢‘å¤„ç†] AudioContextåˆå§‹åŒ–è€—æ—¶: " + (performance.now() - startTime).toFixed(2) + "ms");
            
            const decodeStart = performance.now();
            const binaryData = atob(base64Audio);
            console.log("[éŸ³é¢‘å¤„ç†] Base64è§£ç è€—æ—¶: " + (performance.now() - decodeStart).toFixed(2) + "ms");
            
            const bufferStart = performance.now();
            const arrayBuffer = new ArrayBuffer(binaryData.length);
            const uint8Array = new Uint8Array(arrayBuffer);
            for (let i = 0; i < binaryData.length; i++) {
                uint8Array[i] = binaryData.charCodeAt(i);
            }
            console.log("[éŸ³é¢‘å¤„ç†] åˆ›å»ºUint8Arrayè€—æ—¶: " + (performance.now() - bufferStart).toFixed(2) + "ms");
            
            const convertStart = performance.now();
            const int16Array = new Int16Array(arrayBuffer);
            // è½¬æˆFloat32
            const float32Array = new Float32Array(int16Array.length);
            for (let i = 0; i < int16Array.length; i++) {
                float32Array[i] = int16Array[i] / 32768.0;
            }
            console.log("[éŸ³é¢‘å¤„ç†] æ•°æ®è½¬æ¢è€—æ—¶: " + (performance.now() - convertStart).toFixed(2) + "ms");
            
            audioQueue.push(float32Array);
            
            console.log("[éŸ³é¢‘å¤„ç†] æ€»è€—æ—¶: " + (performance.now() - startTime).toFixed(2) + "ms, æ•°æ®é•¿åº¦: " + float32Array.length);
            
            if (!isPlaying) {
                playNextChunk();
            }
        }

        function playNextChunk() {
            const startTime = performance.now();
            console.log("[éŸ³é¢‘æ’­æ”¾] å¼€å§‹æ’­æ”¾ä¸‹ä¸€å—");
            
            if (audioQueue.length === 0) {
                console.log("[éŸ³é¢‘æ’­æ”¾] éŸ³é¢‘é˜Ÿåˆ—ä¸ºç©ºï¼Œåœæ­¢æ’­æ”¾");
                isPlaying = false;
                isAIPlaying = false;
                return;
            }
            
            isPlaying = true;
            isAIPlaying = true;
            
            const chunk = audioQueue.shift();
            console.log("[éŸ³é¢‘æ’­æ”¾] ä»é˜Ÿåˆ—ä¸­è·å–æ•°æ®è€—æ—¶: " + (performance.now() - startTime).toFixed(2) + "ms, æ•°æ®é•¿åº¦: " + chunk.length);
            
            const bufferStart = performance.now();
            const buffer = audioContext.createBuffer(1, chunk.length, 24000);
            buffer.copyToChannel(chunk, 0);
            console.log("[éŸ³é¢‘æ’­æ”¾] åˆ›å»ºéŸ³é¢‘ç¼“å†²åŒºè€—æ—¶: " + (performance.now() - bufferStart).toFixed(2) + "ms");
            
            const sourceStart = performance.now();
            const source = audioContext.createBufferSource();
            currentAudioSource = source; // ä¿å­˜å½“å‰éŸ³é¢‘æºå¼•ç”¨
            source.buffer = buffer;
            source.connect(audioContext.destination);
            console.log("[éŸ³é¢‘æ’­æ”¾] åˆ›å»ºéŸ³é¢‘æºè€—æ—¶: " + (performance.now() - sourceStart).toFixed(2) + "ms");
            
            source.onended = function() {
                const endTime = performance.now();
                console.log("[éŸ³é¢‘æ’­æ”¾] å½“å‰å—æ’­æ”¾å®Œæˆï¼Œæ’­æ”¾æ—¶é•¿: " + ((endTime - startTime) / 1000).toFixed(2) + "s");
                playNextChunk();
            };
            
            console.log("[éŸ³é¢‘æ’­æ”¾] æ€»å‡†å¤‡è€—æ—¶: " + (performance.now() - startTime).toFixed(2) + "ms");
            source.start();
            console.log("[éŸ³é¢‘æ’­æ”¾] å¼€å§‹æ’­æ”¾");
        }

        // æ·»åŠ åœæ­¢AIæ’­æ”¾çš„å‡½æ•°
        function stopAIPlayback() {
            if (currentAudioSource) {
                try {
                    currentAudioSource.stop();
                    currentAudioSource = null;
                } catch (e) {
                    console.log('åœæ­¢éŸ³é¢‘æ’­æ”¾æ—¶å‡ºé”™:', e);
                }
            }
            audioQueue = []; // æ¸…ç©ºéŸ³é¢‘é˜Ÿåˆ—
            isPlaying = false;
            isAIPlaying = false;
        }

        // å‘é€WebSocketæ¶ˆæ¯
        function sendMessage(message) {
            if (!websocket || websocket.readyState !== WebSocket.OPEN) {
                // å¦‚æœæ˜¯pingæ¶ˆæ¯ä¸”è¿æ¥æœªæ‰“å¼€ï¼Œç›´æ¥å¿½ç•¥
                if (message.type === 'ping') {
                    return;
                }

                console.log('WebSocketæœªè¿æ¥ï¼Œå°è¯•é‡æ–°è¿æ¥');

                // å­˜å‚¨æ¶ˆæ¯ï¼Œè¿æ¥æˆåŠŸåå‘é€
                const pendingMessage = message;
                connectWebSocket();

                // ç­‰å¾…è¿æ¥å»ºç«‹åå‘é€
                const maxAttempts = 3;
                let attempts = 0;

                const checkAndSend = setInterval(() => {
                    attempts++;
                    if (websocket && websocket.readyState === WebSocket.OPEN) {
                        clearInterval(checkAndSend);
                        console.log('è¿æ¥å·²å»ºç«‹ï¼Œå‘é€å»¶è¿Ÿæ¶ˆæ¯');
                        const messageStr = JSON.stringify(pendingMessage);
                        websocket.send(messageStr);
                    } else if (attempts >= maxAttempts) {
                        clearInterval(checkAndSend);
                        console.error('WebSocketè¿æ¥å¤±è´¥ï¼Œæ— æ³•å‘é€æ¶ˆæ¯');
                        statusEl.textContent = "è¿æ¥å¤±è´¥";

                        // å¦‚æœä¸æ˜¯ç³»ç»Ÿæ¶ˆæ¯ï¼Œåˆ™æ˜¾ç¤ºé”™è¯¯æç¤º
                        if (message.type !== 'connect' && message.type !== 'ping') {
                            addMessage("æ— æ³•è¿æ¥åˆ°æœåŠ¡å™¨ï¼Œè¯·åˆ·æ–°é¡µé¢é‡è¯•", "error");
                        }
                    }
                }, 1000);

                return;
            }

            try {
                // è·³è¿‡ç‰¹å®šæ¶ˆæ¯ç±»å‹çš„æ—¥å¿—ï¼ˆå¦‚å¿ƒè·³åŒ…ï¼‰
                if (message.type !== 'ping') {
                  //  console.log('å‘é€æ¶ˆæ¯:', JSON.stringify(message));
                }

                websocket.send(JSON.stringify(message));
            } catch (e) {
                console.error('å‘é€æ¶ˆæ¯å¤±è´¥:', e);

                if (message.type !== 'ping') {
                    addMessage("å‘é€æ¶ˆæ¯å¤±è´¥: " + e.message, "error");
                }

                // å‘é€å¤±è´¥å¯èƒ½æ˜¯è¿æ¥å·²æ–­å¼€ï¼Œå°è¯•é‡è¿
                reconnectIfNeeded();
            }
        }

        // å¼€å§‹å½•éŸ³
        async function startRecording() {
            const recordingStartTime = performance.now();
            console.log('[å½•éŸ³è¿‡ç¨‹] å¼€å§‹å½•éŸ³');
            
            // å¦‚æœAIæ­£åœ¨æ’­æ”¾ï¼Œå…ˆåœæ­¢æ’­æ”¾
            if (isAIPlaying) {
                const stopStart = performance.now();
                stopAIPlayback();
                console.log('[å½•éŸ³è¿‡ç¨‹] åœæ­¢AIæ’­æ”¾è€—æ—¶: ' + (performance.now() - stopStart).toFixed(2) + 'ms');
                addMessage("æ£€æµ‹åˆ°ç”¨æˆ·å¼€å§‹è¯´è¯ï¼Œåœæ­¢å½“å‰æ’­æ”¾", "system");
            }

            // æ£€æŸ¥WebSocketè¿æ¥
            const wsCheckStart = performance.now();
            if (!websocket || websocket.readyState !== WebSocket.OPEN) {
                console.log('[å½•éŸ³è¿‡ç¨‹] WebSocketæœªè¿æ¥ï¼Œå°è¯•è¿æ¥');
                connectWebSocket();
                addMessage("æ­£åœ¨è¿æ¥æœåŠ¡å™¨...", "system");
                await new Promise(resolve => setTimeout(resolve, 1000));

                if (!websocket || websocket.readyState !== WebSocket.OPEN) {
                    console.log('[å½•éŸ³è¿‡ç¨‹] WebSocketè¿æ¥å¤±è´¥');
                    addMessage("è¿æ¥æœåŠ¡å™¨å¤±è´¥ï¼Œè¯·åˆ·æ–°é¡µé¢é‡è¯•", "error");
                    return;
                }
            }
            console.log('[å½•éŸ³è¿‡ç¨‹] WebSocketè¿æ¥æ£€æŸ¥è€—æ—¶: ' + (performance.now() - wsCheckStart).toFixed(2) + 'ms');
            

            try {
                const mediaStartTime = performance.now();
                console.log('[å½•éŸ³è¿‡ç¨‹] å¼€å§‹è®¾ç½®éŸ³é¢‘å‚æ•°');
                
                // è®¾ç½®éŸ³é¢‘å‚æ•°
                const audioConstraints = {
                    audio: {
                        channelCount: AUDIO_CONFIG.numberOfChannels,
                        sampleRate: AUDIO_CONFIG.sampleRate,
                        echoCancellation: true,
                        noiseSuppression: true
                    }
                };

                console.log('[å½•éŸ³è¿‡ç¨‹] è¯·æ±‚éº¦å…‹é£æƒé™');
                const streamStartTime = performance.now();
                const stream = await navigator.mediaDevices.getUserMedia(audioConstraints);
                console.log('[å½•éŸ³è¿‡ç¨‹] è·å–éº¦å…‹é£æµè€—æ—¶: ' + (performance.now() - streamStartTime).toFixed(2) + 'ms');

                // åˆ›å»ºAudioContextå’ŒScriptProcessoræ¥å¤„ç†éŸ³é¢‘æ•°æ®
                const contextStartTime = performance.now();
                const audioContext = new (window.AudioContext || window.webkitAudioContext)({
                    sampleRate: AUDIO_CONFIG.sampleRate
                });
                const audioInput = audioContext.createMediaStreamSource(stream);
                console.log('[å½•éŸ³è¿‡ç¨‹] åˆ›å»ºAudioContextè€—æ—¶: ' + (performance.now() - contextStartTime).toFixed(2) + 'ms');

                // åˆ›å»ºå¤„ç†å™¨èŠ‚ç‚¹
                const processorStartTime = performance.now();
                const bufferSize = 1024; // å‡å°ç¼“å†²åŒºå¤§å°ï¼Œä»4096å‡å°‘åˆ°1024ï¼Œä½¿éŸ³é¢‘å¤„ç†æ›´é¢‘ç¹
                const recorder = audioContext.createScriptProcessor(bufferSize, 1, 1);
                console.log('[å½•éŸ³è¿‡ç¨‹] åˆ›å»ºå¤„ç†å™¨èŠ‚ç‚¹è€—æ—¶: ' + (performance.now() - processorStartTime).toFixed(2) + 'ms');

                // ç”¨äºç´¯ç§¯éŸ³é¢‘æ•°æ®
                let audioBuffer = new Float32Array(0);
                
                console.log('[å½•éŸ³è¿‡ç¨‹] éŸ³é¢‘è®¾ç½®æ€»è€—æ—¶: ' + (performance.now() - mediaStartTime).toFixed(2) + 'ms');
                

                // æ·»åŠ æ—¶é—´æˆ³è·Ÿè¸ª
                let lastSendTime = Date.now();
                
                // æ·»åŠ å¤„ç†è®¡æ•°å™¨å’Œæ€»è®¡æ—¶å™¨
                let processCount = 0;
                const totalRecordingStartTime = performance.now();
                
                recorder.onaudioprocess = function (e) {
                    const processStartTime = performance.now();
                    processCount++;
                    
                    // è·å–éŸ³é¢‘æ•°æ®
                    const buffer = e.inputBuffer.getChannelData(0);
                    
                    if (processCount % 10 === 0) {  // æ¯10æ¬¡å¤„ç†æ‰“å°ä¸€æ¬¡æ—¥å¿—ï¼Œå‡å°‘æ—¥å¿—é‡
                        console.log(`[å½•éŸ³è¿‡ç¨‹] ç¬¬${processCount}æ¬¡éŸ³é¢‘å¤„ç†ï¼Œæ€»è¿è¡Œæ—¶é—´: ${((performance.now() - totalRecordingStartTime)/1000).toFixed(2)}s`);
                    }

                    // å°†æ–°çš„éŸ³é¢‘æ•°æ®ä¸å…ˆå‰çš„æ•°æ®åˆå¹¶
                    const mergeStartTime = performance.now();
                    const newBuffer = new Float32Array(audioBuffer.length + buffer.length);
                    newBuffer.set(audioBuffer);
                    newBuffer.set(buffer, audioBuffer.length);
                    
                    if (processCount % 10 === 0) {
                        console.log(`[å½•éŸ³è¿‡ç¨‹] ç¼“å†²åŒºåˆå¹¶è€—æ—¶: ${(performance.now() - mergeStartTime).toFixed(2)}ms`);
                    }
                    
                    const currentTime = Date.now();
                    const timeSinceLastSend = currentTime - lastSendTime;
                    
                    // å½“ç´¯ç§¯çš„æ•°æ®é‡è¶…è¿‡é˜ˆå€¼æˆ–è€…è¶…è¿‡æœ€å¤§ç¼“å†²æ—¶é—´æ—¶å‘é€
                    if (newBuffer.length >= CHUNK_SIZE || (newBuffer.length > 0 && timeSinceLastSend >= MAX_BUFFER_TIME)) {
                        const sendStartTime = performance.now();
                        
                        // å‘é€ç¼“å†²åŒºä¸­çš„æ‰€æœ‰æ•°æ®
                        const chunkSize = Math.min(newBuffer.length, CHUNK_SIZE);
                        const chunkToSend = newBuffer.slice(0, chunkSize);

                        // ä¿ç•™å‰©ä½™çš„æ•°æ®
                        const remaining = newBuffer.length > chunkSize ? newBuffer.slice(chunkSize) : new Float32Array(0);

                        if (processCount % 10 === 0) {
                            console.log(`[å½•éŸ³è¿‡ç¨‹] å‡†å¤‡å‘é€æ•°æ®ï¼Œé•¿åº¦: ${chunkSize}ï¼Œè€—æ—¶: ${(performance.now() - sendStartTime).toFixed(2)}ms`);
                        }
                        
                        // å°†Float32æ•°æ®è½¬æ¢ä¸º16ä½æ•´æ•°æ ¼å¼
                        const convertStartTime = performance.now();
                        const pcmData = new Int16Array(chunkSize);
                        for (let i = 0; i < chunkSize; i++) {
                            // å°†-1.0 ~ 1.0çš„æµ®ç‚¹æ•°è½¬æ¢ä¸º-32768 ~ 32767çš„æ•´æ•°
                            const s = Math.max(-1, Math.min(1, chunkToSend[i]));
                            pcmData[i] = s < 0 ? s * 0x8000 : s * 0x7FFF;
                        }
                        
                        if (processCount % 10 === 0) {
                            console.log(`[å½•éŸ³è¿‡ç¨‹] æ•°æ®æ ¼å¼è½¬æ¢è€—æ—¶: ${(performance.now() - convertStartTime).toFixed(2)}ms`);
                        }

                        // å°†Int16Arrayè½¬æ¢ä¸ºBlob
                        const blobStartTime = performance.now();
                        const wavBlob = new Blob([pcmData], { type: 'application/octet-stream' });
                        
                        if (processCount % 10 === 0) {
                            console.log(`[å½•éŸ³è¿‡ç¨‹] åˆ›å»ºBlobè€—æ—¶: ${(performance.now() - blobStartTime).toFixed(2)}ms`);
                        }

                        // è½¬æ¢ä¸ºBase64å¹¶å‘é€
                        const base64StartTime = performance.now();
                        const reader = new FileReader();
                        reader.readAsDataURL(wavBlob);
                        reader.onloadend = function () {
                            const base64data = reader.result.split(',')[1];
                            
                            if (processCount % 10 === 0) {
                                console.log(`[å½•éŸ³è¿‡ç¨‹] Base64ç¼–ç è€—æ—¶: ${(performance.now() - base64StartTime).toFixed(2)}ms`);
                                console.log(`[å½•éŸ³è¿‡ç¨‹] å‘é€éŸ³é¢‘æ•°æ®ï¼Œå¤§å°: ${base64data.length} å­—èŠ‚`);
                            }
                            
                            const sendMessageStartTime = performance.now();
                            sendMessage({
                                type: 'audio',
                                audioData: base64data,
                                sessionId: sessionId,
                                timestamp: Date.now()
                            });
                            
                            if (processCount % 10 === 0) {
                                console.log(`[å½•éŸ³è¿‡ç¨‹] å‘é€WebSocketæ¶ˆæ¯è€—æ—¶: ${(performance.now() - sendMessageStartTime).toFixed(2)}ms`);
                                console.log(`[å½•éŸ³è¿‡ç¨‹] æ€»å‘é€è€—æ—¶: ${(performance.now() - sendStartTime).toFixed(2)}ms`);
                            }
                            
                            // æ›´æ–°æœ€åå‘é€æ—¶é—´
                            lastSendTime = Date.now();
                        };

                        // æ›´æ–°ç¼“å†²åŒºä¸ºå‰©ä½™æ•°æ®
                        audioBuffer = remaining;
                    } else {
                        // å¦åˆ™ï¼Œæ›´æ–°ç¼“å†²åŒº
                        audioBuffer = newBuffer;
                    }
                };

                // è¿æ¥å½•éŸ³å¤„ç†é“¾
                audioInput.connect(recorder);
                recorder.connect(audioContext.destination);

                // ä¿å­˜æµå’Œä¸Šä¸‹æ–‡ä»¥ä¾¿åç»­åœæ­¢
                mediaRecorder = {
                    stream: stream,
                    audioContext: audioContext,
                    recorder: recorder,
                    audioInput: audioInput,
                    isRecording: true
                };

                startBtn.disabled = true;
                stopBtn.disabled = false;
                statusEl.textContent = "æ­£åœ¨å½•éŸ³...";

                addMessage("æ­£åœ¨å½•éŸ³...", "user");
            } catch (error) {
                console.error('æ— æ³•è®¿é—®éº¦å…‹é£:', error);
                statusEl.textContent = "æ— æ³•è®¿é—®éº¦å…‹é£";
                addMessage("æ— æ³•è®¿é—®éº¦å…‹é£ï¼Œè¯·ç¡®ä¿å·²æˆäºˆéº¦å…‹é£æƒé™", "error");
            }
        }

        // åœæ­¢å½•éŸ³
        function stopRecording() {
            const stopStartTime = performance.now();
            console.log('[å½•éŸ³è¿‡ç¨‹] å¼€å§‹åœæ­¢å½•éŸ³');
            
            if (mediaRecorder && mediaRecorder.isRecording) {
                // æ–­å¼€å¤„ç†å™¨èŠ‚ç‚¹
                const disconnectStartTime = performance.now();
                mediaRecorder.audioInput.disconnect();
                mediaRecorder.recorder.disconnect();
                console.log('[å½•éŸ³è¿‡ç¨‹] æ–­å¼€å¤„ç†å™¨èŠ‚ç‚¹è€—æ—¶: ' + (performance.now() - disconnectStartTime).toFixed(2) + 'ms');

                // å…³é—­éŸ³é¢‘ä¸Šä¸‹æ–‡
                const closeContextStartTime = performance.now();
                if (mediaRecorder.audioContext.state !== 'closed') {
                    mediaRecorder.audioContext.close();
                }
                console.log('[å½•éŸ³è¿‡ç¨‹] å…³é—­éŸ³é¢‘ä¸Šä¸‹æ–‡è€—æ—¶: ' + (performance.now() - closeContextStartTime).toFixed(2) + 'ms');

                // åœæ­¢æ‰€æœ‰è½¨é“
                const stopTracksStartTime = performance.now();
                mediaRecorder.stream.getTracks().forEach(track => track.stop());
                console.log('[å½•éŸ³è¿‡ç¨‹] åœæ­¢éŸ³é¢‘è½¨é“è€—æ—¶: ' + (performance.now() - stopTracksStartTime).toFixed(2) + 'ms');

                // æ›´æ–°çŠ¶æ€
                mediaRecorder.isRecording = false;

                startBtn.disabled = false;
                stopBtn.disabled = true;
                statusEl.innerHTML = "å¤„ç†ä¸­... <span class='loading'></span>";

                // å‘é€ç»“æŸå½•éŸ³ä¿¡å·
                const sendEndSignalStartTime = performance.now();
                sendMessage({
                    type: 'end_audio',
                    sessionId: sessionId,
                    timestamp: Date.now()
                });
                console.log('[å½•éŸ³è¿‡ç¨‹] å‘é€ç»“æŸå½•éŸ³ä¿¡å·è€—æ—¶: ' + (performance.now() - sendEndSignalStartTime).toFixed(2) + 'ms');
                console.log('[å½•éŸ³è¿‡ç¨‹] åœæ­¢å½•éŸ³æ€»è€—æ—¶: ' + (performance.now() - stopStartTime).toFixed(2) + 'ms');
            }
        }

        // å‘é€æ–‡æœ¬æ¶ˆæ¯
        function sendTextMessage() {
            const text = textInput.value.trim();
            if (text) {
                addMessage(text, "user");

                sendMessage({
                    type: 'text',
                    text: text,
                    sessionId: sessionId,
                    timestamp: Date.now()
                });

                textInput.value = '';
                statusEl.innerHTML = "å¤„ç†ä¸­... <span class='loading'></span>";
            }
        }

        // é‡ç½®ä¼šè¯
        function resetSession() {
            // åœæ­¢å¿ƒè·³
            stopHeartbeat();

            // å–æ¶ˆé‡è¿è®¡åˆ’
            if (reconnectTimeout) {
                clearTimeout(reconnectTimeout);
                reconnectTimeout = null;
            }

            // å…³é—­ç°æœ‰è¿æ¥
            if (websocket) {
                try {
                    websocket.onclose = null; // ç§»é™¤å…³é—­å¤„ç†å™¨ä»¥é¿å…è§¦å‘é‡è¿
                    websocket.close(1000, "ç”¨æˆ·é‡ç½®ä¼šè¯");
                } catch (e) {
                    console.error('å…³é—­WebSocketè¿æ¥å¤±è´¥:', e);
                }
                websocket = null;
            }

            // åœæ­¢å½•éŸ³
            if (mediaRecorder && mediaRecorder.isRecording) {
                stopRecording();
            }

            // æ¸…ç©ºèŠå¤©è®°å½•
            chatContainer.innerHTML = `
                <div class="message robot-message">
                    æ‚¨å¥½ï¼Œæˆ‘æ˜¯RobotPlatformï¼Œè¯·ç‚¹å‡»ä¸‹æ–¹æŒ‰é’®å¼€å§‹æ–°çš„è¯­éŸ³å¯¹è¯ã€‚
                    <div class="message-avatar robot-avatar">AI</div>
                </div>
            `;

            // æ›´æ–°çŠ¶æ€
            statusEl.textContent = "å·²é‡ç½®è¿æ¥";

            // å»¶è¿Ÿä¸€ä¸‹å†é‡æ–°è¿æ¥
            setTimeout(() => {
                connectWebSocket();
            }, 500);
        }

        // æ’­æ”¾éŸ³é¢‘
        function playAudio(base64Audio) {
            if (!base64Audio) {
                console.error('æ— æ•ˆçš„éŸ³é¢‘æ•°æ®');
                return;
            }

            // å¦‚æœæœ‰æ­£åœ¨æ’­æ”¾çš„éŸ³é¢‘ï¼Œå…ˆåœæ­¢
            if (currentAudio && !currentAudio.paused) {
                currentAudio.pause();
            }

            try {
                // è§£ç Base64éŸ³é¢‘æ•°æ®
                const binaryData = atob(base64Audio);
                const arrayBuffer = new ArrayBuffer(binaryData.length);
                const uint8Array = new Uint8Array(arrayBuffer);
                for (let i = 0; i < binaryData.length; i++) {
                    uint8Array[i] = binaryData.charCodeAt(i);
                }

                // åˆ›å»ºAudioContext
                const audioContext = new (window.AudioContext || window.webkitAudioContext)({
                    sampleRate: 24000 // è®¾ç½®é‡‡æ ·ç‡ä¸º24000Hz
                });

                // åˆ›å»ºéŸ³é¢‘æº
                const audioBuffer = audioContext.createBuffer(1, uint8Array.length / 2, 24000);
                const channelData = audioBuffer.getChannelData(0);

                // å°†16ä½PCMæ•°æ®è½¬æ¢ä¸º32ä½æµ®ç‚¹æ•°
                const int16Array = new Int16Array(arrayBuffer);
                for (let i = 0; i < int16Array.length; i++) {
                    channelData[i] = int16Array[i] / 32768.0;
                }

                // åˆ›å»ºéŸ³é¢‘æºå¹¶æ’­æ”¾
                const source = audioContext.createBufferSource();
                source.buffer = audioBuffer;
                source.connect(audioContext.destination);

                // æ·»åŠ æ’­æ”¾æŒ‡ç¤ºå™¨
                const lastRobotMessage = chatContainer.querySelector('.robot-message:last-child');
                if (lastRobotMessage) {
                    const indicator = document.createElement('span');
                    indicator.className = 'playing-indicator';
                    indicator.textContent = 'ğŸ”Š æ­£åœ¨æ’­æ”¾...';
                    lastRobotMessage.appendChild(indicator);

                    source.onended = function () {
                        // ç§»é™¤æ’­æ”¾æŒ‡ç¤ºå™¨
                        if (lastRobotMessage.contains(indicator)) {
                            lastRobotMessage.removeChild(indicator);
                        }
                    };
                }

                // å¼€å§‹æ’­æ”¾
                source.start(0);

            } catch (e) {
                console.error('éŸ³é¢‘æ’­æ”¾é”™è¯¯:', e);
            }
        }

        // æ·»åŠ æ¶ˆæ¯åˆ°èŠå¤©çª—å£
        function addMessage(text, sender) {
            if (!text) {
                console.warn('å°è¯•æ·»åŠ ç©ºæ¶ˆæ¯');
                return;
            }

            const messageDiv = document.createElement('div');

            if (sender === 'user') {
                messageDiv.className = 'message user-message';
                messageDiv.innerHTML = `
                    ${text}
                    <div class="message-time">${formatTime(new Date())}</div>
                    <div class="message-avatar user-avatar">æˆ‘</div>
                `;
            } else if (sender === 'robot') {
                messageDiv.className = 'message robot-message';
                messageDiv.innerHTML = `
                    ${text}
                    <div class="message-time">${formatTime(new Date())}</div>
                    <div class="message-avatar robot-avatar">AI</div>
                `;
            } else if (sender === 'transcription') {
                messageDiv.className = 'message transcription-message';
                messageDiv.innerHTML = `
                    <i>è¯†åˆ«ç»“æœ:</i> ${text}
                    <div class="message-time">${formatTime(new Date())}</div>
                `;
            } else if (sender === 'error') {
                messageDiv.className = 'message error-message';
                messageDiv.textContent = text;
            } else if (sender === 'system') {
                messageDiv.className = 'message system-message';
                messageDiv.textContent = text;
            }

            chatContainer.appendChild(messageDiv);
            chatContainer.scrollTop = chatContainer.scrollHeight;
        }

        // æ ¼å¼åŒ–æ—¶é—´
        function formatTime(date) {
            return `${padZero(date.getHours())}:${padZero(date.getMinutes())}:${padZero(date.getSeconds())}`;
        }

        // æ•°å­—è¡¥é›¶
        function padZero(num) {
            return num < 10 ? '0' + num : num;
        }

        // äº‹ä»¶ç›‘å¬å™¨
        startBtn.addEventListener('click', function () {
            startRecording();
        });

        stopBtn.addEventListener('click', stopRecording);
        resetBtn.addEventListener('click', resetSession);

        sendTextBtn.addEventListener('click', sendTextMessage);
        textInput.addEventListener('keypress', function (e) {
            if (e.key === 'Enter') {
                sendTextMessage();
            }
        });

        // é¡µé¢å¯è§æ€§å˜åŒ–ç›‘å¬
        document.addEventListener('visibilitychange', function () {
            if (document.visibilityState === 'visible') {
                // é¡µé¢å˜ä¸ºå¯è§æ—¶ï¼Œæ£€æŸ¥è¿æ¥çŠ¶æ€
                console.log('é¡µé¢å˜ä¸ºå¯è§ï¼Œæ£€æŸ¥è¿æ¥çŠ¶æ€');
                reconnectIfNeeded();
            }
        });

        // ç›‘å¬ç½‘ç»œçŠ¶æ€å˜åŒ–
        window.addEventListener('online', function () {
            console.log('ç½‘ç»œå·²è¿æ¥ï¼Œå°è¯•é‡è¿WebSocket');
            reconnectIfNeeded();
        });

        // é¡µé¢åŠ è½½æ—¶è¿æ¥WebSocketï¼Œä½†åªè¿æ¥ä¸€æ¬¡
        window.addEventListener('load', function () {
            console.log('é¡µé¢åŠ è½½å®Œæˆï¼Œåˆå§‹åŒ–WebSocketè¿æ¥');
            connectWebSocket();
        });

        // é¡µé¢å…³é—­å‰æ¸…ç†èµ„æº
        window.addEventListener('beforeunload', function () {
            // åœæ­¢å¿ƒè·³
            stopHeartbeat();

            // å…³é—­WebSocketè¿æ¥
            if (websocket) {
                websocket.close(1000, "é¡µé¢å…³é—­");
            }
        });
    </script>
</body>

</html>